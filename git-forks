#!/usr/bin/env python

# This script is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This script is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this script.  If not, see <http://www.gnu.org/licenses/>.

import os
import re
import sys
import json
import argparse
import subprocess
import urllib.request
import configparser


apiPatterns = [
	{"pattern": r"^(git@github.com):(.+)$", "name": "github"},
	{"pattern": r"^(https://github.com)/(.+)$", "name": "github"},
	{"pattern": r"^(git@bitbucket.org):(.+)$", "name": "bitbucket"},
	{"pattern": r"^(https://bitbucket.org)/(.+)$", "name": "bitbucket"},
]

## git Utility functions
def git_getremotes():
	remotes = {}
	config = configparser.ConfigParser()
	config.read(os.path.join(".git","config"))
	for section in config.sections():
		if section[0:6] == "remote":
			remotes[section[8:-1]] = {"url": config[section]["url"]}
	return remotes

def git_addremote(rname, rurl):
	ret = subprocess.call(["git", "remote", "add", rname, rurl])
	if ret != 0:
		print("An error has occurred adding remote '{}' ({}).  Aborting.".format(rname, rurl))
		return(-1)


## Forks functions
def deduceAPI(URI):
	for entry in apiPatterns:
		matches = re.search(entry["pattern"], URI)
		if matches:
			return entry["name"]
	return None

def deduceRepoInfo(URI):
	for entry in apiPatterns:
		matches = re.search(entry["pattern"], URI)
		if matches:
			return matches.group(2).strip(".git").split("/")
	return None

def getforks(apiName, primary=None, remotes=None):
	skippedRemotes = []
	forkList = {}

	if apiName == "github":
		user, repo = deduceRepoInfo(remotes[primary]["url"])
		print("Adding all GitHub forks of {}'s repository named `{}`".format(user, repo))
		with urllib.request.urlopen("https://api.github.com/repos/{}/{}".format(user, repo)) as ghinfo:
			ghinfojson = json.loads(ghinfo.read().decode('utf-8'))

			with urllib.request.urlopen("{}?per_page=100".format(ghinfojson["forks_url"], repo)) as ghforks:
				ghforkjson = json.loads(ghforks.read().decode('utf-8'))
				for fork in ghforkjson:
					forkList[fork["owner"]["login"]] = {"url": fork["git_url"]}

	elif apiName == "bitbucket":
		user, repo = deduceRepoInfo(remotes[primary]["url"])
		print("Adding all Bitbucket forks of {}'s repository named `{}`".format(user, repo))
		with urllib.request.urlopen("https://bitbucket.org/api/2.0/repositories/{}/{}".format(user, repo)) as hostinfo:
			hostinfojson = json.loads(hostinfo.read().decode('utf-8'))

			with urllib.request.urlopen("{}".format(hostinfojson["links"]["forks"]["href"], repo)) as hostforks:
				hostforksjson = json.loads(hostforks.read().decode('utf-8'))
				for fork in hostforksjson["values"]:
					if fork["scm"] == "git":
						for protocol in fork["links"]["clone"]:
							if protocol["name"] == "https":
								forkList[fork["owner"]["username"]] = {"url": protocol["href"]}
	else:
		print("API protocol unrecognized for '{}'. Please file a bug report to request support.".format(apiName))
		return

	for fork in forkList:
		if fork not in remotes:
			git_addremote(fork, forkList[fork]["url"])
		else:
			skippedRemotes.append(fork)

	print("{} forks out of {} added as remotes.".format(len(forkList) - len(skippedRemotes), len(forkList)))

def addall(remoteName):
	remotes = git_getremotes()

	if remoteName in remotes:
		print("Checking remote named `{}` found at {} for forks...".format(remoteName, remotes[remoteName]["url"]))

		apiName = deduceAPI(remotes[remoteName]["url"])
		getforks(apiName, remoteName, remotes)
	else:
		print("Specified remote does not exist.")
		return


def main():
	parser = argparse.ArgumentParser(description='A Utility for interfacing with remote forks.')
	parser.add_argument("-a", "--addall", dest="addall", default="origin", help="Add all forks of the specified remote.")

	args = parser.parse_args()

	# Add further option checks here
	if args.addall is not None:
		addall(args.addall)


if __name__ == '__main__': main()